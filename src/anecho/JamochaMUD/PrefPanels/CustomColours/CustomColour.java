/*
 * CustomColour.java
 *
 * Created on December 10, 2005, 3:28 AM
 * Version $Id: CustomColour.java,v 1.11 2015/06/11 01:57:53 jeffnik Exp $
 */

/* JamochaMUD, a Muck/Mud client program
 * Copyright (C) 1998-2014 Jeff Robinson
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * version 2, as published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 */
package anecho.JamochaMUD.PrefPanels.CustomColours;

import anecho.JamochaMUD.CHandler;
import anecho.JamochaMUD.JMConfig;
import java.awt.Color;
import javax.swing.JPanel;
import javax.swing.table.AbstractTableModel;
import net.sf.wraplog.AbstractLogger;
import net.sf.wraplog.NoneLogger;
import net.sf.wraplog.SystemLogger;

/**
 *
 * @author jeffnik
 */
public class CustomColour extends javax.swing.JPanel implements anecho.JamochaMUD.PrefPanels.PrefInterface {
// public class CustomColour extends anecho.JamochaMUD.PrefPanels.PrefInterface {

    /**
     * Creates new form CustomColour
     */
    public CustomColour() {
//    private CustomColour() {

        if (DEBUG) {
            logger = new SystemLogger();
        } else {
            logger = new NoneLogger();
        }

        logger.debug("Creating new CustomColour instance");

        //       initComponents();
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {
        java.awt.GridBagConstraints gridBagConstraints;

        final javax.swing.JLabel jLabel1 = new javax.swing.JLabel();
        colourTable = new javax.swing.JTable(new colourTableModel());
        colourTable.setDefaultRenderer(Color.class, new ColourCellRenderer());
        colourTable.setDefaultEditor(Color.class, new ColourCellEditor());
        final javax.swing.JButton resetAll = new javax.swing.JButton();
        final javax.swing.JButton standardButton = new javax.swing.JButton();
        backgroundCB = new javax.swing.JCheckBox();

        setLayout(new java.awt.GridBagLayout());

        jLabel1.setBackground(javax.swing.UIManager.getDefaults().getColor("InternalFrame.activeTitleBackground"));
        jLabel1.setFont(new java.awt.Font("Dialog", 1, 18)); // NOI18N
        java.util.ResourceBundle bundle = java.util.ResourceBundle.getBundle("anecho/JamochaMUD/PrefPanels/CustomColours/ColourBundle"); // NOI18N
        jLabel1.setText(bundle.getString("Custom_output_colour")); // NOI18N
        jLabel1.setOpaque(true);
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridwidth = 3;
        gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;
        gridBagConstraints.insets = new java.awt.Insets(5, 5, 5, 5);
        add(jLabel1, gridBagConstraints);

        setPrefPaletteColours();
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 1;
        gridBagConstraints.gridwidth = 3;
        gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;
        gridBagConstraints.insets = new java.awt.Insets(5, 5, 5, 5);
        add(colourTable, gridBagConstraints);

        resetAll.setMnemonic(java.util.ResourceBundle.getBundle("anecho/JamochaMUD/PrefPanels/CustomColours/ColourBundle").getString("CustomColours.resetButtonMnemonic").charAt(0));
        resetAll.setText(bundle.getString("Reset_All")); // NOI18N
        resetAll.setToolTipText(bundle.getString("Reset_all_colours_to_current_palette")); // NOI18N
        resetAll.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                resetAllActionPerformed(evt);
            }
        });
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 3;
        gridBagConstraints.insets = new java.awt.Insets(5, 5, 5, 5);
        add(resetAll, gridBagConstraints);

        standardButton.setMnemonic(java.util.ResourceBundle.getBundle("anecho/JamochaMUD/PrefPanels/CustomColours/ColourBundle").getString("CustomColours.standardButtonMnemonic").charAt(0));
        standardButton.setText(bundle.getString("Standard_Colours")); // NOI18N
        standardButton.setToolTipText(bundle.getString("Change_colours_to_standard")); // NOI18N
        standardButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                standardButtonActionPerformed(evt);
            }
        });
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 2;
        gridBagConstraints.gridy = 3;
        gridBagConstraints.insets = new java.awt.Insets(5, 5, 5, 5);
        add(standardButton, gridBagConstraints);

        backgroundCB.setMnemonic(java.util.ResourceBundle.getBundle("anecho/JamochaMUD/PrefPanels/CustomColours/ColourBundle").getString("CustomColour.backgroundCBMnemonic").charAt(0));
        backgroundCB.setText(bundle.getString("Enable_lettering_background_colour")); // NOI18N
        backgroundCB.setBorder(javax.swing.BorderFactory.createEmptyBorder(0, 0, 0, 0));
        backgroundCB.setMargin(new java.awt.Insets(0, 0, 0, 0));
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 2;
        gridBagConstraints.gridwidth = 3;
        gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;
        gridBagConstraints.insets = new java.awt.Insets(5, 5, 5, 5);
        add(backgroundCB, gridBagConstraints);
    }// </editor-fold>//GEN-END:initComponents
    private void resetAllActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_resetAllActionPerformed
        // Reset the colours the most recent colour settings
        setPrefPaletteColours();
    }//GEN-LAST:event_resetAllActionPerformed

    private void standardButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_standardButtonActionPerformed
        // Set the current palette to the standard colours
        setStandardColours();
    }//GEN-LAST:event_standardButtonActionPerformed

    /**
     * This method is required by our Interface to return a human-readable title
     * for our module.
     *
     * @return A string representing the human-readable name of our module.
     */
    @Override
    public String getModuleName() {
        final String retStr = java.util.ResourceBundle.getBundle("anecho/JamochaMUD/PrefPanels/CustomColours/ColourBundle").getString("Custom_Colours");
        return retStr;
    }

    /**
     *
     * @return
     */
    @Override
    public JPanel loadPanel() {
        // Check to see if components have already been initialised
        if (colourTable == null) {

            logger.debug("CustomColour.Loading new panel");

            // Initialise our components
            initComponents();

            // Setup the colours in our table
            setPrefPaletteColours();

            // Set the background colour checkbox
            final JMConfig settings = JMConfig.getInstance();
            backgroundCB.setSelected(settings.getJMboolean(JMConfig.BGPAINT));

            // This change should be propagated back through all the open MU*s
            // Fix Me XXX
        } else {

            logger.debug("CustomColour.Panel already loaded");

        }

        return this;
    }

    /**
     * Save the settings for this module
     */
    @Override
    public void applySettings() {

        logger.debug("CustomColour.applySettings() has been called.");

        // Set the new palette colours
        setNewPaletteColours();

        // Set the background colouring state
        final JMConfig settings = JMConfig.getInstance();
        final boolean paintBG = backgroundCB.isSelected();
        settings.setJMboolean(JMConfig.BGPAINT, Boolean.toString(paintBG));

        // Cycle through existing MU*s and change BGPAINT option
        final CHandler tempCHandler = settings.getConnectionHandler();
        final java.util.Vector conns = tempCHandler.getAllMUs();

        final int connLen = conns.size();

        anecho.JamochaMUD.MuSocket tempMU;

        for (int i = 0; i < connLen; i++) {
            tempMU = (anecho.JamochaMUD.MuSocket) conns.elementAt(i);
            tempMU.enableBackgroundPainting(paintBG);
        }
    }

    class colourTableModel extends AbstractTableModel {
        
        final transient private String[] columnNames = {java.util.ResourceBundle.getBundle("anecho/JamochaMUD/PrefPanels/CustomColours/ColourBundle").getString("Colour"),
            java.util.ResourceBundle.getBundle("anecho/JamochaMUD/PrefPanels/CustomColours/ColourBundle").getString("Normal"),
            java.util.ResourceBundle.getBundle("anecho/JamochaMUD/PrefPanels/CustomColours/ColourBundle").getString("Bold")
        };
        private final transient Object[][] data = {
            {java.util.ResourceBundle.getBundle("anecho/JamochaMUD/PrefPanels/CustomColours/ColourBundle").getString("Black"), new Color(153, 0, 153), new Color(153, 0, 153)},
            {java.util.ResourceBundle.getBundle("anecho/JamochaMUD/PrefPanels/CustomColours/ColourBundle").getString("Red"), new Color(51, 51, 153), new Color(153, 0, 153)},
            {java.util.ResourceBundle.getBundle("anecho/JamochaMUD/PrefPanels/CustomColours/ColourBundle").getString("Green"), new Color(51, 102, 51), new Color(153, 0, 153)},
            {java.util.ResourceBundle.getBundle("anecho/JamochaMUD/PrefPanels/CustomColours/ColourBundle").getString("Yellow"), Color.red, new Color(153, 0, 153)},
            {java.util.ResourceBundle.getBundle("anecho/JamochaMUD/PrefPanels/CustomColours/ColourBundle").getString("Blue"), Color.red, new Color(153, 0, 153)},
            {java.util.ResourceBundle.getBundle("anecho/JamochaMUD/PrefPanels/CustomColours/ColourBundle").getString("Magenta"), Color.red, new Color(153, 0, 153)},
            {java.util.ResourceBundle.getBundle("anecho/JamochaMUD/PrefPanels/CustomColours/ColourBundle").getString("Cyan"), Color.red, new Color(153, 0, 153)},
            {java.util.ResourceBundle.getBundle("anecho/JamochaMUD/PrefPanels/CustomColours/ColourBundle").getString("White"), Color.pink, new Color(153, 0, 153)}};

        /**
         * This method returns the number of columns in our table.
         *
         * @return Number of columns in our table
         */
        @Override
        public int getColumnCount() {
            logger.debug("CustomColour.getColumnCount() called.");
            
            final int cCount = columnNames.length;

            return cCount;
        }

        /**
         * This method returns the number of rows in our table.
         *
         * @return Number of rows in our table.
         */
        @Override
        public int getRowCount() {
            logger.debug("CustomColour.getRowCount() called.");
            
            final int rCount = data.length;

            return rCount;
        }

        /**
         *
         * @param row
         * @param col
         * @return
         */
        @Override
        public Object getValueAt(final int row, final int col) {
            
            logger.debug("CustomColour.getValueAt called.");
            final Object retObj = data[row][col];

            return retObj;
        }

        /*
         * JTable uses this method to determine the default renderer/
         * editor for each cell.  If we didn't implement this method,
         * then the last column would contain text ("true"/"false"),
         * rather than a check box.
         */
        /**
         *
         * @param col
         * @return
         */
        @Override
        public Class getColumnClass(final int col) {
          
            logger.debug("CustomColour.getColumnClass.");
            final Class retClass = getValueAt(0, col).getClass();
            return retClass;
        }

        /**
         * This method returns a boolean indicating whether this cell may be
         * edited.
         *
         * @param row The row of our selected table cell.
         * @param col The column of our selected table cell.
         * @return This boolean represents whether the cell may be:
         * <CODE>true</CODE> edited <CODE>false</CODE> not edited
         */
        @Override
        public boolean isCellEditable(final int row, final int col) {
            logger.debug("CustomColour.isCellEditable called.");
            boolean retVal = true;

            if (col < 1) {
                retVal = false;
            }

            return retVal;
        }

        /**
         * This method sets the value for a given cell in our table.
         *
         * @param value This object represents the value that our table cell
         * should contain.
         * @param row This represents the table row of our selected cell.
         * @param col This represents the table column of our selected cell.
         */
        @Override
        public void setValueAt(final Object value, final int row, final int col) {
            logger.debug("CustomColour.setValueAt called.");
            data[row][col] = value;
            fireTableCellUpdated(row, col);

        }
    }

    private void setPrefPaletteColours() {
        logger.debug("CustomColour.setPrefPaletteColours() called");
        final JMConfig settings = JMConfig.getInstance();
        // java.awt.Color[] newPal;
        // newPal = (Color[]) settings.getJMObject(JMConfig.CUSTOMPALETTE);
        java.awt.Color[] newPal = new Color[16];
        
        logger.debug("CustomColour.setPrefPaletteColours() says the current palette from config is " + newPal);
        // logger.debug("There are " + newPal.length + " items in this palette.");
        // logger.debug("The first colour in newPal is " + newPal[0]);
        
        for (int i = 0; i < 16; i++) {
            newPal[i] = new Color(settings.getJMint(JMConfig.CUSTOMPALETTE + i));
        }
        
        if (newPal == null || newPal[0] == null) {

            logger.debug("CustomColour.setPrefPaletteColours() We got a null result for JMConfig.CUSTOMPALETTE");
            logger.debug("We will get the colours from the JMSwingText.");
            
            // final CHandler handler = settings.getConnectionHandler();
            final CHandler handler = CHandler.getInstance();
            final anecho.gui.JMSwingText jmst = handler.getActiveMUDSwingText();

            if (jmst == null) {
                final anecho.gui.JMSwingText tempText = new anecho.gui.JMSwingText();
                newPal = tempText.getCurrentPalette();

                logger.debug("PrefDialogue.setPrefPaletteColours: we have no active connections"
                        + "creating a temporary JMSwingText to get a palette.");

            } else {
                logger.debug("CustomColour.setPrefPalette() JMSwingText is not null.  Pulling colours from existing palette.");
                newPal = jmst.getCurrentPalette();

            }

        }

        if (newPal == null) {
            logger.debug("PrefDialogue.setPrefPaletteColours returned null");

            return;
        }

        int xCol, yCol;
        final colourTableModel mtm = (colourTableModel) colourTable.getModel();

        for (int i = 0; i < 16; i++) {
            if (i < 8) {
                xCol = 1;
                yCol = i;
            } else {
                xCol = 2;
                yCol = i - 8;
            }

            mtm.setValueAt(newPal[i], yCol, xCol);
        }
    }

    private void setNewPaletteColours() {
        logger.debug("CustomColour.setNewPaletteColours() called.");

        // This should be written to a configuration file, or our settings
        final JMConfig settings = JMConfig.getInstance();
        final CHandler handler = settings.getConnectionHandler();

        // Collect the colours
        Color[] newPal = new Color[16];
        int xCol, yCol;
        final colourTableModel mtm = (colourTableModel) colourTable.getModel();

        for (int i = 0; i < 16; i++) {
            if (i < 8) {
                xCol = 1;
                yCol = i;
            } else {
                xCol = 2;
                yCol = i - 8;
            }
            newPal[i] = (Color) mtm.getValueAt(yCol, xCol);
            logger.debug("Writing out " + newPal[i]);

        }

        // Save the new palette to our configuration
        settings.setJMValue(JMConfig.CUSTOMPALETTE, newPal);

//        for (int i = 0; i < 16; i++) {
//            settings.setJMValue(JMConfig.CUSTOMPALETTE + i, newPal[i]);
//        }
//        
        handler.setCustomPalette(newPal);
    }

    /**
     * set our new palette to the standard palette
     */
    private void setStandardColours() {

        logger.debug("CustomColour.setStandarColours() called.");
        final JMConfig settings = JMConfig.getInstance();
        final CHandler handler = settings.getConnectionHandler();
        // final anecho.gui.JMSwingText jmst = handler.getActiveMUDSwingText();

        final anecho.gui.JMSwingText jmst;

        if (handler.totalConnections() > 0) {
            jmst = handler.getActiveMUDSwingText();
        } else {
            jmst = new anecho.gui.JMSwingText();
        }

        // Collect the colours
        final Color[] newPal = jmst.getStandardColours();

        int xCol, yCol;
        final colourTableModel mtm = (colourTableModel) colourTable.getModel();

        for (int i = 0; i < 16; i++) {
            if (i < 8) {
                xCol = 1;
                yCol = i;
            } else {
                xCol = 2;
                yCol = i - 8;
            }

            mtm.setValueAt(newPal[i], yCol, xCol);
        }

    }

    /**
     * This module has no special requirements
     */
    @Override
    public boolean checkVersion() {
        return true;
    }

    /**
     * There is no warning as there are no special requirements
     */
    @Override
    public void versionWarning() {
        /* There is no warning as there are no special requirements */
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private transient javax.swing.JCheckBox backgroundCB;
    private transient javax.swing.JTable colourTable;
    // End of variables declaration//GEN-END:variables

    /**
     * Enables or disables debugging output
     */
    private static final boolean DEBUG = false;
    private final AbstractLogger logger;
    // private CustomColour cusCol;
}
