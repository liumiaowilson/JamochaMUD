/*
 * ExtWorldList.java
 *
 * Created on October 16, 2008, 8:48 PM
 */
package anecho.JamochaMUD;

import java.io.BufferedOutputStream;
import java.io.BufferedReader;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStream;
import java.net.MalformedURLException;
import java.net.URL;
import java.net.URLConnection;
import java.util.Vector;
import javax.swing.DefaultListModel;
import javax.swing.JOptionPane;
// import javax.swing.text.Document;
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import net.sf.wraplog.AbstractLogger;
import net.sf.wraplog.NoneLogger;
import net.sf.wraplog.SystemLogger;
import org.w3c.dom.Element;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import org.xml.sax.SAXException;

/**
 *
 * @author jeffnik
 */
public class ExtWorldList extends javax.swing.JDialog {

    /**
     * Creates new form ExtWorldList
     *
     * @param parent The parent frame of this dialogue
     * @param modal If this dialogue should be displayed modally.
     */
    public ExtWorldList(final java.awt.Frame parent, final boolean modal) {
        super(parent, modal);

        if (DEBUG) {
            logger = new SystemLogger();
        } else {
            logger = new NoneLogger();
        }

        // Load settings from JMConfig
        listAddress = JMConfig.getInstance().getJMString(JMConfig.EXTMUDLIST);
        logger.debug("ExtWorldList.ExtWorldList setting listAddress as : " + listAddress);
        
        initComponents();

        // Download the list
        // downloadList();
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {
        java.awt.GridBagConstraints gridBagConstraints;

        final javax.swing.JScrollPane jScrollPane1 = new javax.swing.JScrollPane();
        muList = new javax.swing.JList();
        nameTF = new javax.swing.JTextField();
        addressTF = new javax.swing.JTextField();
        portTF = new javax.swing.JTextField();
        final javax.swing.JLabel nameLabel = new javax.swing.JLabel();
        final javax.swing.JLabel addressLabel = new javax.swing.JLabel();
        final javax.swing.JLabel portLabel = new javax.swing.JLabel();
        final javax.swing.JLabel ratingLabel = new javax.swing.JLabel();
        descL = new javax.swing.JLabel();
        final javax.swing.JPanel buttonPanel = new javax.swing.JPanel();
        final javax.swing.JButton connectB = new javax.swing.JButton();
        final javax.swing.JButton importB = new javax.swing.JButton();
        final javax.swing.JButton cancelB = new javax.swing.JButton();
        final javax.swing.JScrollPane muDescSP = new javax.swing.JScrollPane();
        muDescTP = new javax.swing.JTextPane();
        final javax.swing.JLabel worldListLabel = new javax.swing.JLabel();

        setDefaultCloseOperation(javax.swing.WindowConstants.DISPOSE_ON_CLOSE);
        java.util.ResourceBundle bundle = java.util.ResourceBundle.getBundle("anecho/JamochaMUD/JamochaMUDBundle"); // NOI18N
        setTitle(bundle.getString("IMPORT WORLDS")); // NOI18N
        setCursor(new java.awt.Cursor(java.awt.Cursor.DEFAULT_CURSOR));
        setMinimumSize(new java.awt.Dimension(500, 500));
        getContentPane().setLayout(new java.awt.GridBagLayout());

        muList.setModel(worldListModel);
        muList.setSelectionMode(javax.swing.ListSelectionModel.SINGLE_SELECTION);
        muList.setToolTipText(bundle.getString("ExtWorldListmuList")); // NOI18N
        muList.addListSelectionListener(new javax.swing.event.ListSelectionListener() {
            public void valueChanged(javax.swing.event.ListSelectionEvent evt) {
                muListValueChanged(evt);
            }
        });
        jScrollPane1.setViewportView(muList);
        muList.getAccessibleContext().setAccessibleName(bundle.getString("ExtWorldListListName")); // NOI18N

        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 1;
        gridBagConstraints.gridwidth = java.awt.GridBagConstraints.REMAINDER;
        gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;
        gridBagConstraints.insets = new java.awt.Insets(3, 3, 3, 3);
        getContentPane().add(jScrollPane1, gridBagConstraints);

        nameTF.setEditable(false);
        nameTF.setToolTipText(bundle.getString("ExtWorldListnameToolTip")); // NOI18N
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 1;
        gridBagConstraints.gridy = 2;
        gridBagConstraints.gridwidth = java.awt.GridBagConstraints.REMAINDER;
        gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;
        gridBagConstraints.weightx = 1.0;
        gridBagConstraints.insets = new java.awt.Insets(3, 3, 0, 3);
        getContentPane().add(nameTF, gridBagConstraints);

        addressTF.setEditable(false);
        addressTF.setToolTipText(bundle.getString("ExtWorldListaddressToolTip")); // NOI18N
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 1;
        gridBagConstraints.gridy = 3;
        gridBagConstraints.gridwidth = java.awt.GridBagConstraints.REMAINDER;
        gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;
        gridBagConstraints.insets = new java.awt.Insets(3, 3, 0, 3);
        getContentPane().add(addressTF, gridBagConstraints);

        portTF.setEditable(false);
        portTF.setToolTipText(bundle.getString("ExtWorldListPortToolTip")); // NOI18N
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 1;
        gridBagConstraints.gridy = 4;
        gridBagConstraints.gridwidth = java.awt.GridBagConstraints.REMAINDER;
        gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;
        gridBagConstraints.insets = new java.awt.Insets(3, 3, 0, 3);
        getContentPane().add(portTF, gridBagConstraints);

        nameLabel.setDisplayedMnemonic(java.util.ResourceBundle.getBundle("anecho/JamochaMUD/JamochaMUDBundle").getString("ExtWorldListNameLabelMnemonic").charAt(0));
        nameLabel.setLabelFor(nameTF);
        nameLabel.setText(bundle.getString("NAME:")); // NOI18N
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 2;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;
        gridBagConstraints.insets = new java.awt.Insets(3, 3, 0, 0);
        getContentPane().add(nameLabel, gridBagConstraints);

        addressLabel.setDisplayedMnemonic(java.util.ResourceBundle.getBundle("anecho/JamochaMUD/JamochaMUDBundle").getString("ExtWorldListAddressLabelMnemonic").charAt(0));
        addressLabel.setLabelFor(addressTF);
        addressLabel.setText(bundle.getString("ADDRESS:")); // NOI18N
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 3;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;
        gridBagConstraints.insets = new java.awt.Insets(3, 3, 0, 0);
        getContentPane().add(addressLabel, gridBagConstraints);

        portLabel.setDisplayedMnemonic(java.util.ResourceBundle.getBundle("anecho/JamochaMUD/JamochaMUDBundle").getString("ExtWorldListPortLabelMnemonic").charAt(0));
        portLabel.setLabelFor(portTF);
        portLabel.setText(bundle.getString("PORT:")); // NOI18N
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 4;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;
        gridBagConstraints.insets = new java.awt.Insets(3, 3, 0, 0);
        getContentPane().add(portLabel, gridBagConstraints);

        ratingLabel.setText(bundle.getString("RATING:")); // NOI18N
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 5;
        gridBagConstraints.gridwidth = java.awt.GridBagConstraints.REMAINDER;
        gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;
        gridBagConstraints.insets = new java.awt.Insets(3, 3, 0, 3);
        getContentPane().add(ratingLabel, gridBagConstraints);

        descL.setDisplayedMnemonic(java.util.ResourceBundle.getBundle("anecho/JamochaMUD/JamochaMUDBundle").getString("ExtWorldListDescLabelMnemonic").charAt(0));
        descL.setLabelFor(muDescTP);
        descL.setText(bundle.getString("DESCRIPTION:")); // NOI18N
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 6;
        gridBagConstraints.gridwidth = java.awt.GridBagConstraints.REMAINDER;
        gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;
        gridBagConstraints.insets = new java.awt.Insets(3, 3, 0, 3);
        getContentPane().add(descL, gridBagConstraints);

        connectB.setMnemonic(java.util.ResourceBundle.getBundle("anecho/JamochaMUD/JamochaMUDBundle").getString("ExtWorldListConnectButton").charAt(0));
        connectB.setText(bundle.getString("CONNECT")); // NOI18N
        connectB.setToolTipText(bundle.getString("ExtWorldListConnectButtonToolTip")); // NOI18N
        connectB.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                connectBActionPerformed(evt);
            }
        });
        buttonPanel.add(connectB);

        importB.setMnemonic(java.util.ResourceBundle.getBundle("anecho/JamochaMUD/JamochaMUDBundle").getString("ExtWorldListImportButtonMnemonic").charAt(0));
        importB.setText(bundle.getString("IMPORT ONLY")); // NOI18N
        importB.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                importBActionPerformed(evt);
            }
        });
        buttonPanel.add(importB);

        cancelB.setMnemonic(java.util.ResourceBundle.getBundle("anecho/JamochaMUD/JamochaMUDBundle").getString("ExtWorldListCancelButtonMnemonic").charAt(0));
        cancelB.setText(bundle.getString("CANCEL")); // NOI18N
        cancelB.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                cancelBActionPerformed(evt);
            }
        });
        buttonPanel.add(cancelB);

        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 8;
        gridBagConstraints.gridwidth = java.awt.GridBagConstraints.REMAINDER;
        gridBagConstraints.gridheight = java.awt.GridBagConstraints.REMAINDER;
        getContentPane().add(buttonPanel, gridBagConstraints);

        muDescTP.setText(bundle.getString("WHEN YOU SELECT A MU* FROM THE LIST ABOVE ITS DESCRIPTION (IF AVAILABLE) WILL APPEAR HERE.  FOR REMOTE WEB PAGES THERE MAY BE A NOTICABLE DELAY.")); // NOI18N
        muDescTP.setMinimumSize(new java.awt.Dimension(6, 100));
        muDescSP.setViewportView(muDescTP);

        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 7;
        gridBagConstraints.gridwidth = java.awt.GridBagConstraints.REMAINDER;
        gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.NORTHWEST;
        gridBagConstraints.weighty = 1.0;
        gridBagConstraints.insets = new java.awt.Insets(5, 3, 0, 3);
        getContentPane().add(muDescSP, gridBagConstraints);

        worldListLabel.setDisplayedMnemonic(java.util.ResourceBundle.getBundle("anecho/JamochaMUD/JamochaMUDBundle").getString("ExtWorldListWorldListLabelMnemonic").charAt(0));
        worldListLabel.setLabelFor(muList);
        worldListLabel.setText(bundle.getString("AVAILABLE WORLDS:")); // NOI18N
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 0;
        gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;
        gridBagConstraints.insets = new java.awt.Insets(3, 3, 3, 3);
        getContentPane().add(worldListLabel, gridBagConstraints);

        getAccessibleContext().setAccessibleDescription(bundle.getString("ExtWorldListAccessibleDescription")); // NOI18N

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void muListValueChanged(javax.swing.event.ListSelectionEvent evt) {//GEN-FIRST:event_muListValueChanged
        updateMUInfo();
    }//GEN-LAST:event_muListValueChanged

    private void connectBActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_connectBActionPerformed
        connectToWorld();
    }//GEN-LAST:event_connectBActionPerformed

    private void importBActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_importBActionPerformed
        addWorld();
    }//GEN-LAST:event_importBActionPerformed

    private void cancelBActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_cancelBActionPerformed
        this.setVisible(false);
        this.dispose();
    }//GEN-LAST:event_cancelBActionPerformed

    /**
     * create a local file name based on the provided URL. this file will be
     * used to save the list to avoid repeatedly hitting the remote server for
     * the list as well as making the list available off-line
     */
    private String parseLocalFileName(final URL urlName) {
        final String completeFilePart = urlName.getFile();
        final String filePart = completeFilePart.substring(completeFilePart.lastIndexOf('/'));
        final String localPath = JMConfig.getInstance().getJMString(JMConfig.USERDIRECTORY);
        final int pathLen = localPath.length() - 1;

        final String localFileName = localPath.substring(0, pathLen) + filePart + java.util.ResourceBundle.getBundle("anecho/JamochaMUD/JamochaMUDBundle").getString("_LOCAL.TXT");

        logger.debug(java.util.ResourceBundle.getBundle("anecho/JamochaMUD/JamochaMUDBundle").getString("EXTWORLDLIST.PARSELOCALFILENAME RETURNING: ") + localFileName);

        return localFileName;
    }

    private String parseLocalFileName(final String urlName) {
        URL tempURL;
        String retStr;

        logger.debug(java.util.ResourceBundle.getBundle("anecho/JamochaMUD/JamochaMUDBundle").getString("EXTWORLDLIST.PARSELOCALFILENAME(STRING): RECEIVED URL: ") + urlName);

        try {
            // tempURL = new URL(listAddress);
            tempURL = new URL(urlName);
            retStr = parseLocalFileName(tempURL);
        } catch (MalformedURLException ex) {
            // Logger.getLogger(ExtWorldList.class.getName()).log(Level.SEVERE, null, ex);
            logger.error("ExtWorldList.parseLocalFileName: MalformedURLException", ex);
            // This probably isn't that great.  Fix Me XXX
            retStr = java.util.ResourceBundle.getBundle("anecho/JamochaMUD/JamochaMUDBundle").getString("FOO");
        }

        logger.debug(java.util.ResourceBundle.getBundle("anecho/JamochaMUD/JamochaMUDBundle").getString("EXTWORLDLIST.PARSELOCALFILENAME(STRING): RETURNING NAME: ") + retStr);

        return retStr;
    }

    /*
     * This method sets up the list of available MU*s
     */
    public void createList() {
        // make certain we have the most up-to-date version of the list
        downloadList2();

        // parse the file
        final Vector wList = parseMuList();

        // fill the world list
        displayList(wList);

    }

    /*
     * This is the revised download method as of 2010-02-15.  This method will
     * compare the remote version of the MU* list to the local one.  If the remote
     * file is newer (or the local file does not exist) then the remote file is
     * downloaded to the local system.
     * 
     */
    private void downloadList2() {

        // Check to see if an address has been defined
        if (listAddress.equals("")) {
            JOptionPane.showMessageDialog(this, java.util.ResourceBundle.getBundle("anecho/JamochaMUD/JamochaMUDBundle").getString("NO ADDRESS HAS BE PROVIDED FOR THE MU* LIST."), java.util.ResourceBundle.getBundle("anecho/JamochaMUD/JamochaMUDBundle").getString("NO LIST ADDRESS"), JOptionPane.ERROR_MESSAGE);
            return;
        }

        // Grab the file via HTTP
        URL listURL;
        URLConnection listConn;
        InputStream listInput;

        try {
            // listURL = new URL("http://" + listAddress);
            listURL = new URL(listAddress);
            listConn = listURL.openConnection();
            listInput = listConn.getInputStream();
        } catch (java.net.UnknownHostException uhe) {
            JOptionPane.showMessageDialog(this, java.util.ResourceBundle.getBundle("anecho/JamochaMUD/JamochaMUDBundle").getString("CANNOT CONNECT TO ADDRESS TO RETRIEVE MU* NAMES.") + '\n' + java.util.ResourceBundle.getBundle("anecho/JamochaMUD/JamochaMUDBundle").getString("THE EXISTING LIST OF MU* SERVERS WILL BE SHOWN.") + '\n' + '(' + listAddress + ')', java.util.ResourceBundle.getBundle("anecho/JamochaMUD/JamochaMUDBundle").getString("CANNOT CONNECT TO ADDRESS"), JOptionPane.ERROR_MESSAGE);
            return;
        } catch (IOException urlExc) {

            String title = java.util.ResourceBundle.getBundle("anecho/JamochaMUD/JamochaMUDBundle").getString("BAD ADDRESS");
            String message = java.util.ResourceBundle.getBundle("anecho/JamochaMUD/JamochaMUDBundle").getString("BAD ADDRESS PROVIDED FOR MU* LIST.");
            
            // JOptionPane.showMessageDialog(this, java.util.ResourceBundle.getBundle("anecho/JamochaMUD/JamochaMUDBundle").getString("BAD ADDRESS PROVIDED FOR MU* LIST."), java.util.ResourceBundle.getBundle("anecho/JamochaMUD/JamochaMUDBundle").getString("BAD ADDRESS"), JOptionPane.ERROR_MESSAGE);
            JOptionPane.showMessageDialog(this, message + listAddress, title, JOptionPane.ERROR_MESSAGE);

            logger.debug(java.util.ResourceBundle.getBundle("anecho/JamochaMUD/JamochaMUDBundle").getString("EXTWORLDLIST.GETMUDLISTSLIST() ERROR: ") + urlExc);

            return;
        }

        // Check if the date of the existing local file is newer than the remote file
        final String localFileStr = parseLocalFileName(listURL);
        final File localFile = new File(localFileStr);
        // long localFileDate = new File(localFileStr).lastModified();
        long localFileDate;

        // If the local file does not exist we will make the local date 0 to force a download
        if (localFile.exists()) {
            localFileDate = localFile.lastModified();
        } else {
            localFileDate = 0;
        }
        final long remoteFileDate = listConn.getLastModified();

        logger.debug(java.util.ResourceBundle.getBundle("anecho/JamochaMUD/JamochaMUDBundle").getString("EXTWORLDLIST.DOWNLOADLIST2() REMOTE FILE DATE: ") + remoteFileDate);
        logger.debug(java.util.ResourceBundle.getBundle("anecho/JamochaMUD/JamochaMUDBundle").getString("EXTWORLDLIST.DOWNLOADLIST2() LOCAL FILE DATE: ") + localFileDate);

        // The remote file is newer, so we'll need to download it
        if (remoteFileDate > localFileDate) {
            // Use the local file as it has not been updated remotely.
            // File localFile = new File(localFileStr);

            logger.debug(java.util.ResourceBundle.getBundle("anecho/JamochaMUD/JamochaMUDBundle").getString("EXTWORLDLIST.DOWNLOADLIST2() GOING TO DOWNLOAD REMOTE FILE."));

            try {
                try (BufferedOutputStream outStream = new BufferedOutputStream(new FileOutputStream(localFileStr))) {
                    final byte[] buf = new byte[1024];
                    int byteRead;
                    
                    logger.debug(java.util.ResourceBundle.getBundle("anecho/JamochaMUD/JamochaMUDBundle").getString("EXTWORLDLIST.DOWNLOADLIST2() BEGINNING DOWNLOAD OF REMOTE FILE."));
                    
                    // We should have a status bar indicator here.  Fix me XXX
                    while ((byteRead = listInput.read(buf)) != -1) {
                        outStream.write(buf, 0, byteRead);
                        // byteWritten += ByteRead;
                    }
                    
                    outStream.flush();
                }

                logger.debug(java.util.ResourceBundle.getBundle("anecho/JamochaMUD/JamochaMUDBundle").getString("EXTWORLDLIST.DOWNLOADLIST2() COMPLETED DOWNLOADING OF REMOTE FILE."));

                // Update the time stamp on the file.  If we don't there could be discrepancies
                // between the local clock and the remote server, which could cause the file
                // to always be downloaded even though it hasn't changed.
                // File dateFile = new File(localFileStr);
                final boolean success = localFile.setLastModified(remoteFileDate);

                if (success) {
                    logger.debug(java.util.ResourceBundle.getBundle("anecho/JamochaMUD/JamochaMUDBundle").getString("EXTWORLDLIST.DOWNLOADLIST2() SCCESSFULLY UPDATED TIME-STAMP ON LOCAL FILE"));
                    logger.debug(java.util.ResourceBundle.getBundle("anecho/JamochaMUD/JamochaMUDBundle").getString("NEW TIME-STAMP IS ") + localFile.lastModified());
                } else {
                    logger.debug(java.util.ResourceBundle.getBundle("anecho/JamochaMUD/JamochaMUDBundle").getString("EXTWORLDLIST.DOWNLOADLIST2() FAILED TO UPDATE TIME-STAMP ON LOCAL FILE"));
                }
            } catch (IOException outExc) {

                logger.debug(java.util.ResourceBundle.getBundle("anecho/JamochaMUD/JamochaMUDBundle").getString("EXTWORLDLIST.DOWNLOADLIST2() EXCEPTION CREATING OUTSTREAM: ") + outExc);
                // Create a good user error message here.  Fix Me XXX

            }
        } else {

            logger.debug(java.util.ResourceBundle.getBundle("anecho/JamochaMUD/JamochaMUDBundle").getString("EXTWORLDLIST.DOWNLOADLIST2(): EXISTING LIST IS MOST CURRENT."));

        }

        // We are done!
    }

    /**
     * This is the generic call to gather the MU* list. The list is downloaded
     * in this method and then parsed in the appropriate style depending on the
     * site it came from
     *
     * @deprecated Deprecated to use downloadList2
     */
    public void downloadList() {
        // Download the MUD list file

        // Check to see if an address has been defined
        if (listAddress.equals("")) {
            JOptionPane.showMessageDialog(this, java.util.ResourceBundle.getBundle("anecho/JamochaMUD/JamochaMUDBundle").getString("NO ADDRESS HAS BE PROVIDED FOR THE MU* LIST."), java.util.ResourceBundle.getBundle("anecho/JamochaMUD/JamochaMUDBundle").getString("NO LIST ADDRESS"), JOptionPane.ERROR_MESSAGE);
            return;
        }

        // Grab the file via HTTP
        URL listURL;
        URLConnection listConn;
        InputStream listInput;

        try {
            // listURL = new URL("http://" + listAddress);
            listURL = new URL(listAddress);
            listConn = listURL.openConnection();
            listInput = listConn.getInputStream();

            // Check if the date of the existing local file is newer than the remote file
            final String localFileStr = parseLocalFileName(listURL);
            final long localFileDate = new File(localFileStr).lastModified();
            final long remoteFileDate = listConn.getDate();

            if (localFileDate >= remoteFileDate) {
                // Use the local file as it has not been updated remotely.
                final File localFile = new File(localFileStr);

            }

            // 
        } catch (IOException urlExc) {
            JOptionPane.showMessageDialog(this, java.util.ResourceBundle.getBundle("anecho/JamochaMUD/JamochaMUDBundle").getString("BAD ADDRESS PROVIDED FOR MU* LIST."), java.util.ResourceBundle.getBundle("anecho/JamochaMUD/JamochaMUDBundle").getString("BAD ADDRESS"), JOptionPane.ERROR_MESSAGE);

            logger.debug(java.util.ResourceBundle.getBundle("anecho/JamochaMUD/JamochaMUDBundle").getString("EXTWORLDLIST.GETMUDLISTSLIST() ERROR: ") + urlExc);

            return;
        }

//        try {
//            final DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
//            final DocumentBuilder builder = factory.newDocumentBuilder();
//            final org.w3c.dom.Document doc = builder.parse(listInput);
//            doc.getDocumentElement().normalize();
//
//            Vector worldList;
//
//            // Determine the type of list we're importing
//            final String listType = JMConfig.getInstance().getJMString(JMConfig.MUDLISTTYPE).toLowerCase();
//
//            if (listType.equals("mudlists")) {
//                worldList = getMudListsList(doc);
//            } else {
//                worldList = this.getUndefinedList(doc);
//            }
//
//            // Write out the list
//            displayList(worldList);
//
//        } catch (Exception xmlExc) {
//            if (DEBUG) {
//                logger.debug("ExtWorldList.getList XML error: " + xmlExc);
//            }
//
//            return;
//        }
        Vector worldList = new Vector();
        final String listType = JMConfig.getInstance().getJMString(JMConfig.MUDLISTTYPE).toLowerCase();

        if (listType.equals(MUDLISTS) || listType.equals(java.util.ResourceBundle.getBundle("anecho/JamochaMUD/JamochaMUDBundle").getString("XML"))) {
            worldList = parseXMLList(listInput);
        } else {
            // right now we'll default to a comma-delimited list
            //            worldList = parseTabList(listInput);
        }

        if (!worldList.isEmpty()) {
            displayList(worldList);
        } else {
            // Give the user a warning that we couldn't display the list.  Fix Me XXX
        }

    }

    private Vector parseMuList() {
        // Decide the proper parser to use
        // Determine the type of list we're importing
        final String listType = JMConfig.getInstance().getJMString(JMConfig.MUDLISTTYPE).toLowerCase();
        final String fileName = parseLocalFileName(listAddress);
        Vector worldList = new Vector();

        if (listType.equals(MUDLISTS) || listType.equals(java.util.ResourceBundle.getBundle("anecho/JamochaMUD/JamochaMUDBundle").getString("XML"))) {
            try {
                final FileInputStream listInput = new FileInputStream(fileName);
                final DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
                final DocumentBuilder builder = factory.newDocumentBuilder();
                final org.w3c.dom.Document doc = builder.parse(listInput);
                doc.getDocumentElement().normalize();

                if (listType.equals(MUDLISTS)) {
                    worldList = getMudListsList(doc);
                } else {
                    worldList = getUndefinedList(doc);
                }
            } catch (Exception exc) {

                logger.debug(java.util.ResourceBundle.getBundle("anecho/JamochaMUD/JamochaMUDBundle").getString("EXTWORLDLIST.PARSEMULIST() EXCEPTION PARSING MUDLISTS: ") + exc);

            }
        } else {
            worldList = parseTabList(fileName);
        }

        return worldList;
    }

    private Vector parseXMLList(final InputStream listInput) {
        Vector worldList = new Vector();

        try {
            final DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
            final DocumentBuilder builder = factory.newDocumentBuilder();
            final org.w3c.dom.Document doc = builder.parse(listInput);
            doc.getDocumentElement().normalize();

            // Determine the type of list we're importing
            final String listType = JMConfig.getInstance().getJMString(JMConfig.MUDLISTTYPE).toLowerCase();

            if (listType.equals(MUDLISTS)) {
                worldList = getMudListsList(doc);
            } else {
                worldList = this.getUndefinedList(doc);
            }
        } catch (ParserConfigurationException | SAXException | IOException xmlExc) {
            // Warn the user that there is an error.  Fix Me XXX

            logger.debug(java.util.ResourceBundle.getBundle("anecho/JamochaMUD/JamochaMUDBundle").getString("EXTWORLDLIST.PARSEXMLLIST(INPUTSTREAM) ERROR ") + xmlExc);

        }

        return worldList;
    }

    private Vector parseTabList(final String fileName) {
        final Vector worldList = new Vector();

        // We will read in the file and then parse the tab delimited columns
        // into their proper category
        // 0 - Name
        // 1 - Address
        // 2 - Port
        // Hard-coded for now
        final int name = 0;
        final int address = 1;
        final int port = 2;

        String inLine;
//        String tempName;
//        String tempAddress;
        int tempPort;

        World tempWorld;

        try {
            // Load in the list from a file and then parse it apart
            // FileInputStream inStream = new FileInputStream(fileName);
            final BufferedReader bufRead = new BufferedReader(new FileReader(fileName));
            try {
                while ((inLine = bufRead.readLine()) != null) {
                    tempWorld = new World();

                    // We only need to try and parse the line if it contains a tab
                    if (inLine.indexOf('\t') > 0) {
                        // Now split apart the line based on the tabs
                        final String parts[] = inLine.split("\t");

                        if (parts.length > name) {
                            tempWorld.setWorldName(parts[name]);
                        }

                        if (parts.length > address) {
                            tempWorld.setAddress(parts[address]);
                        }

                        if (parts.length > port) {
                            tempPort = Integer.parseInt(parts[port]);
                            tempWorld.setPort(tempPort);
                        }
                    }

                    if (tempWorld.isValidWorld()) {
                        worldList.addElement(tempWorld);
                    }
                }

            } catch (IOException ex) {
                // Logger.getLogger(ExtWorldList.class.getName()).log(Level.SEVERE, null, ex);
                logger.debug("ExtWorldList.parseTabList IOException " + ex);
            }

        } catch (FileNotFoundException ex) {
            // Logger.getLogger(ExtWorldList.class.getName()).log(Level.SEVERE, null, ex);
            logger.debug("ExtWorldList.parseTabList FileNotFoundException", ex);
        }

        return worldList;
    }

    /**
     * This method parses lists received from MudLists.com In the future most of
     * the parsing method can be broken out and only the specific tag names need
     * be here
     *
     */
    private Vector getMudListsList(final org.w3c.dom.Document xmlDoc) {

        final String worldTag = java.util.ResourceBundle.getBundle("anecho/JamochaMUD/JamochaMUDBundle").getString("MUDS");
        final String worldNameTag = java.util.ResourceBundle.getBundle("anecho/JamochaMUD/JamochaMUDBundle").getString("NAME");
        final String worldAddressTag = java.util.ResourceBundle.getBundle("anecho/JamochaMUD/JamochaMUDBundle").getString("ADDRESS");
        final String worldPortTag = java.util.ResourceBundle.getBundle("anecho/JamochaMUD/JamochaMUDBundle").getString("PORT");
        final String worldRatingTag = java.util.ResourceBundle.getBundle("anecho/JamochaMUD/JamochaMUDBundle").getString("RATING");
        final String worldDescTag = java.util.ResourceBundle.getBundle("anecho/JamochaMUD/JamochaMUDBundle").getString("INFO");

        return parseXMLMudList(xmlDoc, worldTag, worldNameTag, worldAddressTag, worldPortTag, worldRatingTag, worldDescTag);

    }

    /**
     * Parse the elements provided doing only the simplest match of name,
     * address, and port
     *
     * @param xmlDoc
     * @return
     */
    private Vector getUndefinedList(final org.w3c.dom.Document xmlDoc) {
        Vector retVect = new Vector();

        final String orgStr = JMConfig.getInstance().getJMString(JMConfig.MANUALEXTLIST);

        final String[] splitStr = orgStr.split(":");

        // The given string must split into world, name, address, and port or we'll fail
        if (splitStr.length == 4) {
            retVect = parseXMLMudList(xmlDoc, splitStr[0], splitStr[1], splitStr[2], splitStr[3], "", "");

        } else {
            // The given "schema" is unusable.  Let the user know.
            JOptionPane.showMessageDialog(this,
                    java.util.ResourceBundle.getBundle("anecho/JamochaMUD/JamochaMUDBundle").getString("THE GIVEN XML TAGS ARE NOT VALID, REMOTE LIST NOT LOADED."),
                    java.util.ResourceBundle.getBundle("anecho/JamochaMUD/JamochaMUDBundle").getString("INVALID XML TAGS"),
                    JOptionPane.ERROR_MESSAGE);

        }

        return retVect;

    }

//    private Vector parseTabbedMudList(int name, int address, int port) {
//        Vector retVect = new Vector();
//
//        return retVect;
//    }
    /**
     * Parse the provided XML file using the provided tags
     *
     * @param xmlDoc
     * @param worldTag
     * @param worldNameTag
     * @param worldAddressTag
     * @param worldPortTag
     * @return
     */
    private Vector parseXMLMudList(
            final org.w3c.dom.Document xmlDoc,
            final String worldTag,
            final String worldNameTag,
            final String worldAddressTag,
            final String worldPortTag,
            final String worldRatingTag,
            final String worldDescTag) {
        final Vector worldList = new Vector();

        final NodeList listOfWorlds = xmlDoc.getElementsByTagName(worldTag);

        final int worldCount = listOfWorlds.getLength();

        logger.debug(java.util.ResourceBundle.getBundle("anecho/JamochaMUD/JamochaMUDBundle").getString("OUR XML FILE CONTAINS ") + worldCount + " tags <" + worldTag + ">");

        for (int i = 0; i
                < worldCount; i++) {
            final World tempWorld = new World();

            final Node worldNode = listOfWorlds.item(i);

            final Element firstWorldElement = (Element) worldNode;

            // Get the world name
            final NodeList worldNameList = firstWorldElement.getElementsByTagName(worldNameTag);
            final Element worldNameElement = (Element) worldNameList.item(0);

            final NodeList worldNameNodeList = worldNameElement.getChildNodes();
            final String worldName = worldNameNodeList.item(0).getNodeValue();
            tempWorld.setWorldName(worldName);

            System.out.println(java.util.ResourceBundle.getBundle("anecho/JamochaMUD/JamochaMUDBundle").getString("WORLD NAME : ") + worldName);

            // get the world address
            final NodeList worldAddressList = firstWorldElement.getElementsByTagName(worldAddressTag);
            final Element worldAddressElement = (Element) worldAddressList.item(0);

            final NodeList worldAddressNodeList = worldAddressElement.getChildNodes();
            final String worldAddress = worldAddressNodeList.item(0).getNodeValue();
            tempWorld.setAddress(worldAddress);

            System.out.println(java.util.ResourceBundle.getBundle("anecho/JamochaMUD/JamochaMUDBundle").getString("WORLD ADDRESS : ") + worldAddress);

            // get the world port
            final NodeList worldPortList = firstWorldElement.getElementsByTagName(worldPortTag);
            final Element worldPortElement = (Element) worldPortList.item(0);

            final NodeList worldPortNodeList = worldPortElement.getChildNodes();
            final String worldPort = worldPortNodeList.item(0).getNodeValue();
            tempWorld.setPort(Integer.parseInt(worldPort));

            System.out.println(java.util.ResourceBundle.getBundle("anecho/JamochaMUD/JamochaMUDBundle").getString("WORLD PORT : ") + worldPort);

            // Check for the optional tags
            if (!worldDescTag.equals("")) {
                // Fill in the supplied description tags
                final NodeList worldDescList = firstWorldElement.getElementsByTagName(worldDescTag);
                final Element worldDescElement = (Element) worldDescList.item(0);

                final NodeList worldDescNodeList = worldDescElement.getChildNodes();
                final String worldDesc = worldDescNodeList.item(0).getNodeValue();
                tempWorld.setNotes(worldDesc);

            }

            worldList.addElement(tempWorld);

        }

        logger.debug(java.util.ResourceBundle.getBundle("anecho/JamochaMUD/JamochaMUDBundle").getString("EXTWORLDLIST.GETMUDLISTSLIST.COMPLETED DOWNLOADING WORLD LIST."));

        return worldList;

    }

    /**
     * Set the address to download the lists from. This needs to be a fully
     * qualified URL (including the target file)
     *
     * @param address The address that contains the MU* list
     */
    public void setListAddress(final String address) {

        logger.debug(java.util.ResourceBundle.getBundle("anecho/JamochaMUD/JamochaMUDBundle").getString("EXTWORLDLIST.SETLISTADDRESS SET TO ") + address);

        listAddress = address;

    }

    /**
     * Return the current address used for downloading the lists
     *
     * @return Returns a string of the current list address
     */
    public String getListAddress() {
        return listAddress;

    }

    /**
     * Set the connect world and dismiss this dialogue
     */
    private void connectToWorld() {
        if (muList.getSelectedIndex() > -1) {
            connectWorldVar = (World) muList.getSelectedValue();

        }

        this.setVisible(false);

    }

    /**
     *
     * @return
     */
    public World getConnectWorld() {
        return connectWorldVar;

    }

    /**
     * This method adds the world to the user's permanent list
     *
     */
    private void addWorld() {
        final World tempWorld = (World) muList.getSelectedValue();

        addWorldVar = tempWorld;

        this.setVisible(false);

    }

    /**
     * This method returns the world a user has selected to export
     *
     * @return
     */
    public World getAddWorld() {
        return addWorldVar;

    }

    /**
     * Update the display with the given list of worlds
     *
     * @param worldList A vector of World objects
     */
    private void displayList(final Vector worldList) {
        if (worldListModel == null) {
            worldListModel = new DefaultListModel();

        } // empty any existing elements first
        worldListModel.removeAllElements();

        // Add the elements
        if (!worldList.isEmpty()) {
            final int len = worldList.size();

            for (int i = 0; i
                    < len; i++) {
                worldListModel.addElement((World) worldList.elementAt(i));

            }
        }
    }

    /**
     * This method updates the MU* details when the user clicks on a world from
     * the list
     */
    private void updateMUInfo() {
        final World tempWorld = (World) muList.getSelectedValue();

        nameTF.setText(tempWorld.getWorldName());
        addressTF.setText(tempWorld.getAddress());
        portTF.setText(Integer.toString(tempWorld.getPort()));

        final String tempDesc = tempWorld.getNotes();

        // if (tempDesc != null && !tempDesc.equals("")) {
        if (tempDesc != null) {
            if (tempDesc.equals("")) {
                muDescTP.setText(java.util.ResourceBundle.getBundle("anecho/JamochaMUD/JamochaMUDBundle").getString("DESCRIPTION NOT AVAILABLE FOR ") + tempWorld.getWorldName());
            } else {

                try {
                    // Try to show the given information as a URL
                    // muDescTP.setText("Loading " + tempDesc);
                    descL.setText(java.util.ResourceBundle.getBundle("anecho/JamochaMUD/JamochaMUDBundle").getString("LOADING..."));
                    final URL tempUrl = new URL(tempDesc);
                    muDescTP.setPage(tempUrl);
                    descL.setText(java.util.ResourceBundle.getBundle("anecho/JamochaMUD/JamochaMUDBundle").getString("DESCRIPTION"));
                    muDescTP.setCaretPosition(0);

                } catch (IOException exc) {
                    // Set the given description as plain text
                    muDescTP.setText(tempDesc);

                }
            }
        }
    }
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private transient javax.swing.JTextField addressTF;
    private transient javax.swing.JLabel descL;
    private transient javax.swing.JTextPane muDescTP;
    private transient javax.swing.JList muList;
    private transient javax.swing.JTextField nameTF;
    private transient javax.swing.JTextField portTF;
    // End of variables declaration//GEN-END:variables
    /**
     * The fully qualified Internet address for the mu* list
     */
    private String listAddress = "";
    /**
     * Enable and disable debugging output
     */
    private static final boolean DEBUG = false;
    /**
     * The list model used for displaying worlds
     */
    private transient DefaultListModel worldListModel = new DefaultListModel();
    /**
     * The world to be used if the user has chosen to add the world to the
     * existing list
     */
    private transient World addWorldVar;
    /**
     * The world to use if the user has chosen to connect
     */
    private transient World connectWorldVar;
    private static final String MUDLISTS = java.util.ResourceBundle.getBundle("anecho/JamochaMUD/JamochaMUDBundle").getString("MUDLISTS");
    private final AbstractLogger logger;
}
